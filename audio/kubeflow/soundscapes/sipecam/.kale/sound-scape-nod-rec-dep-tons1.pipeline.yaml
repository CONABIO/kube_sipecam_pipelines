apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: sound-scape-nod-rec-dep-tons1-
  annotations: {pipelines.kubeflow.org/kfp_sdk_version: 1.8.11, pipelines.kubeflow.org/pipeline_compilation_time: '2022-05-06T12:27:18.309431',
    pipelines.kubeflow.org/pipeline_spec: '{"description": "Computes Sipecam Soundscapes
      using cumulus, node, recorder and deployment", "inputs": [{"default": "CORE",
      "name": "BLUE_IDX", "optional": true}, {"default": "92", "name": "CUMULO", "optional":
      true}, {"default": "96", "name": "FREQUENCY_BINS", "optional": true}, {"default":
      "0", "name": "FREQUENCY_LIMITS_LB", "optional": true}, {"default": "24000",
      "name": "FREQUENCY_LIMITS_UB", "optional": true}, {"default": "INFORMATION",
      "name": "GREEN_IDX", "optional": true}, {"default": "48", "name": "HASHER_TIME_MODULE",
      "optional": true}, {"default": "1800", "name": "HASHER_TIME_UNIT", "optional":
      true}, {"default": "crono_hash_30m", "name": "HASH_NAME", "optional": true},
      {"default": "10000", "name": "MIN_FREQ_SC", "optional": true}, {"default": "1000",
      "name": "PAGESIZE", "optional": true}, {"default": "EXAG", "name": "RED_IDX",
      "optional": true}, {"default": "/shared_volume/audio/soundscapes", "name": "RESULTS_DIR",
      "optional": true}, {"default": "48000.0", "name": "SAMPLERATE", "optional":
      true}, {"default": "Audible", "name": "SPECTRUM", "optional": true}, {"default":
      "2", "name": "THREADS_PER_WORKER", "optional": true}, {"default": "30", "name":
      "TIME_UNIT", "optional": true}, {"default": ".", "name": "WORK_DIR_PIPELINE",
      "optional": true}, {"default": "hostpath-pvc", "name": "vol_shared_volume",
      "optional": true}], "name": "sound-scape-nod-rec-dep-tons1"}'}
  labels: {pipelines.kubeflow.org/kfp_sdk_version: 1.8.11}
spec:
  entrypoint: sound-scape-nod-rec-dep-tons1
  templates:
  - name: compute-soundscapes
    container:
      args: [--BLUE-IDX, '{{inputs.parameters.BLUE_IDX}}', --CUMULO, '{{inputs.parameters.CUMULO}}',
        --FREQUENCY-BINS, '{{inputs.parameters.FREQUENCY_BINS}}', --FREQUENCY-LIMITS-LB,
        '{{inputs.parameters.FREQUENCY_LIMITS_LB}}', --FREQUENCY-LIMITS-UB, '{{inputs.parameters.FREQUENCY_LIMITS_UB}}',
        --GREEN-IDX, '{{inputs.parameters.GREEN_IDX}}', --HASHER-TIME-MODULE, '{{inputs.parameters.HASHER_TIME_MODULE}}',
        --HASHER-TIME-UNIT, '{{inputs.parameters.HASHER_TIME_UNIT}}', --HASH-NAME,
        '{{inputs.parameters.HASH_NAME}}', --MIN-FREQ-SC, '{{inputs.parameters.MIN_FREQ_SC}}',
        --RED-IDX, '{{inputs.parameters.RED_IDX}}', --RESULTS-DIR, '{{inputs.parameters.RESULTS_DIR}}',
        --SPECTRUM, '{{inputs.parameters.SPECTRUM}}', --THREADS-PER-WORKER, '{{inputs.parameters.THREADS_PER_WORKER}}',
        --TIME-UNIT, '{{inputs.parameters.TIME_UNIT}}', --WORK-DIR-PIPELINE, '{{inputs.parameters.WORK_DIR_PIPELINE}}']
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - "def compute_soundscapes(BLUE_IDX, CUMULO, FREQUENCY_BINS, FREQUENCY_LIMITS_LB,\
        \ FREQUENCY_LIMITS_UB, GREEN_IDX, HASHER_TIME_MODULE, HASHER_TIME_UNIT, HASH_NAME,\
        \ MIN_FREQ_SC, RED_IDX, RESULTS_DIR, SPECTRUM, THREADS_PER_WORKER, TIME_UNIT,\
        \ WORK_DIR_PIPELINE):\n    _kale_pipeline_parameters_block = '''\n    BLUE_IDX\
        \ = \"{}\"\n    CUMULO = {}\n    FREQUENCY_BINS = {}\n    FREQUENCY_LIMITS_LB\
        \ = {}\n    FREQUENCY_LIMITS_UB = {}\n    GREEN_IDX = \"{}\"\n    HASHER_TIME_MODULE\
        \ = {}\n    HASHER_TIME_UNIT = {}\n    HASH_NAME = \"{}\"\n    MIN_FREQ_SC\
        \ = {}\n    RED_IDX = \"{}\"\n    RESULTS_DIR = \"{}\"\n    SPECTRUM = \"\
        {}\"\n    THREADS_PER_WORKER = {}\n    TIME_UNIT = {}\n    WORK_DIR_PIPELINE\
        \ = \"{}\"\n    '''.format(BLUE_IDX, CUMULO, FREQUENCY_BINS, FREQUENCY_LIMITS_LB,\
        \ FREQUENCY_LIMITS_UB, GREEN_IDX, HASHER_TIME_MODULE, HASHER_TIME_UNIT, HASH_NAME,\
        \ MIN_FREQ_SC, RED_IDX, RESULTS_DIR, SPECTRUM, THREADS_PER_WORKER, TIME_UNIT,\
        \ WORK_DIR_PIPELINE)\n\n    from kale.common import mlmdutils as _kale_mlmdutils\n\
        \    _kale_mlmdutils.init_metadata()\n\n    _kale_data_loading_block = '''\n\
        \    # -----------------------DATA LOADING START--------------------------------\n\
        \    from kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"\
        /shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\"\
        )\n    recs = _kale_marshal.load(\"recs\")\n    # -----------------------DATA\
        \ LOADING END----------------------------------\n    '''\n\n    _kale_block1\
        \ = '''\n    import datetime\n    import hashlib\n    import json\n    import\
        \ multiprocessing \n    import matplotlib.pyplot as plt\n    import os\n \
        \   import pandas as pd\n    import psutil\n    import shutil\n    import\
        \ subprocess\n    import time\n\n    from dask.distributed import Client,\
        \ LocalCluster\n    from datetime import timedelta\n    from dotenv import\
        \ load_dotenv\n    from os.path import exists as file_exists\n\n    from yuntu.collection.methods\
        \ import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n\
        \    from yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n\
        \    from yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape,\
        \ HASHER_CONFIG\n    '''\n\n    _kale_block2 = '''\n    def create_results_folder_str(results_dir,\
        \ cumulo, nodes_list, rec_list, dep_list): \n        # results directory\n\
        \        os.makedirs(results_dir, exist_ok=True)\n        # cumulus subdir\n\
        \        cum_subdir = os.path.join(results_dir, str(cumulo))\n        os.makedirs(cum_subdir,\
        \ exist_ok=True)\n        # node subdirs\n        for node in nodes_list:\n\
        \            node_subdir = os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir,\
        \ exist_ok=True)\n            # recorder subdirs\n            for rec in rec_list:\n\
        \                rec_subdir = os.path.join(node_subdir, rec)\n           \
        \     os.makedirs(rec_subdir, exist_ok=True)\n                # deployment\
        \ subdirs\n                for dep in dep_list:\n                    dep_subdir\
        \ = os.path.join(rec_subdir, dep)\n                    os.makedirs(dep_subdir,\
        \ exist_ok=True)\n\n    def remove_empty_folders(path_abs):\n        walk\
        \ = list(os.walk(path_abs))\n        for path, _, _ in walk[::-1]:\n     \
        \       if len(os.listdir(path)) == 0:\n                os.rmdir(path)   \
        \         \n\n    def save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent=\"Null\"):\n        if product_type == \"soundscape\":\n        \
        \    product_name = \"Soundscape\"\n            file_path = os.path.join(path,\
        \ \"hashed_soundscape.parquet\")\n            metadata_filename = os.path.join(path,\
        \ \"soundscape_metadata.json\")\n        elif product_type == \"sequence\"\
        :\n            product_name = \"Soundscape sequential plot\"\n           \
        \ file_path = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename\
        \ = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type\
        \ == \"standard_deviation\":\n            product_name = \"Soundscape standard\
        \ deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"std_soundscape_metadata.json\"\
        )\n        elif product_type == \"mean\":\n            product_name = \"Soundscape\
        \ mean plot\"\n            file_path = os.path.join(path, \"mean_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"mean_soundscape_metadata.json\"\
        )\n\n        if int(node.split(\"_\")[2]) == 0:\n            node_category\
        \ = \"Degradado\"\n        elif int(node.split(\"_\")[2]) == 1:\n        \
        \    node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\"\
        : product_id,\n            \"product_parent\": parent,\n            \"product_name\"\
        : product_name,\n            \"product_configs\": sc_config,\n           \
        \ \"product_path\": file_path,\n            \"product_spectrum\": product_spectrum,\n\
        \            \"CumulusName\": cumulus,\n            \"NodeCategoryIntegrity\"\
        : node_category,\n            \"NomenclatureNode\": node,\n            \"\
        SerialNumber\": recorder,\n            \"DateDeployment\": deployment\n  \
        \      }\n\n        with open(metadata_filename, 'w', encoding='utf-8') as\
        \ f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n\
        \    def plot_soundscape(soundscape, product_type, product_spectrum, sc_config,\
        \ path, \n                        cumulus, node, recorder, deployment, parent,\
        \ indices, min_freq=None,\n                      figsize=(20,15), plt_style='ggplot'):\n\
        \n        if min_freq:\n            soundscape = soundscape[soundscape['min_freq']<=min_freq]\n\
        \n        if product_type == \"sequence\":\n            file_path = os.path.join(path,\
        \ \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_sequence(rgb=indices, time_format='%Y-%m\
        \ %H:%M', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n\
        \            plt.tight_layout()\n            plt.savefig(file_path) \n   \
        \         plt.show()\n            # save metadata\n            save_metadata(product_id,\
        \ product_type, product_spectrum, sc_config,\n                      path,\
        \ cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type\
        \ == \"standard_deviation\":\n            file_path = os.path.join(path, \"\
        std_soundscape.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"std\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\
        \ \n            plt.savefig(file_path)\n            plt.show()\n\n       \
        \     # save metadata\n            save_metadata(product_id, product_type,\
        \ product_spectrum, sc_config,\n                      path, cumulus, node,\
        \ recorder, deployment, parent)     \n\n        elif product_type == \"mean\"\
        : \n            file_path = os.path.join(path, \"mean_soundscape.png\")\n\
        \            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"mean\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n\
        \            plt.savefig(file_path)\n            plt.show()\n\n          \
        \  # save metadata\n            save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent)    \n\n        print(f\"File saved at {file_path}\")\n    '''\n\n\
        \    _kale_block3 = '''\n    execution_info = {}\n    # start_time = time.monotonic()\n\
        \    start_time_compute_soundscapes = time.monotonic()\n    # hasher config\
        \ \n    hasher_config = {'module': {'object_name': 'yuntu.soundscape.hashers.crono.CronoHasher'},\n\
        \                     'kwargs': {'time_utc_column': 'abs_start_time'}}\n\n\
        \    hasher_config[\"kwargs\"][\"time_unit\"] = HASHER_TIME_UNIT\n    hasher_config[\"\
        kwargs\"][\"time_module\"] = HASHER_TIME_MODULE\n    hasher_config[\"kwargs\"\
        ][\"start_tzone\"] = \"America/Mexico_City\"\n    hasher_config[\"kwargs\"\
        ][\"start_time\"] = DEFAULT_HASHER_CONFIG[\"start_time\"]\n    hasher_config[\"\
        kwargs\"][\"start_format\"] = DEFAULT_HASHER_CONFIG[\"start_format\"]\n  \
        \  hasher_config[\"kwargs\"][\"aware_start\"] = None\n\n    # soundscape config\
        \ \n    slice_config  = dict(CronoSoundscape()[\"slice_config\"].data)\n \
        \   slice_config[\"time_unit\"] = TIME_UNIT\n    slice_config[\"frequency_bins\"\
        ] = FREQUENCY_BINS\n    slice_config[\"frequency_limits\"] = (FREQUENCY_LIMITS_LB,\
        \ FREQUENCY_LIMITS_UB)\n\n    # fed configuration [\"TOTAL\", \"CORE\", \"\
        TAIL\", \"INFORMATION\", \"ICOMPLEXITY\", \"EXAG\"]\n    indices = CronoSoundscape()[\"\
        indices\"].data + [ICOMPLEXITY()]  + [TAIL()]\n\n    # dask local cluster\n\
        \    n_workers = int(0.95 * multiprocessing .cpu_count()) \n    cluster =\
        \ LocalCluster(n_workers = n_workers, \n                           threads_per_worker\
        \ = THREADS_PER_WORKER)\n    client = Client(cluster)\n    npartitions = len(client.ncores())\n\
        \n    # FEED\n    FEED = {\n        \"slice_config\": slice_config,\n    \
        \    \"indices\": indices,\n        \"hash_name\": HASH_NAME,\n        \"\
        hasher_config\": hasher_config,\n        \"npartitions\": npartitions\n  \
        \  }\n\n    # adjust for metadata\n    indexes_computed = [\"TOTAL\", \"CORE\"\
        , \"TAIL\", \"INFORMATION\", \"ICOMPLEXITY\", \"EXAG\"]\n    FEED_metadata\
        \ = FEED.copy()\n    FEED_metadata[\"indices\"] = indexes_computed\n\n   \
        \ plot_indices = [RED_IDX, GREEN_IDX, BLUE_IDX] #rgb order\n    # soundscape\
        \ per unit\n    proc_units = recs.proc_unit.unique()\n\n    for proc_unit\
        \ in proc_units:\n        try: \n            start_soundscape = time.monotonic()\n\
        \            node, recorder, deployment = proc_unit\n            print(f\"\
        * Processing: node {node} | recorder {recorder} | deployment date {deployment}\"\
        )\n            file_path = os.path.join(RESULTS_DIR, str(CUMULO), str(node),\
        \ recorder, deployment)\n            parent_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \            # soundscape = recs[recs.proc_unit == proc_unit].audio.get_soundscape(client=client,\
        \ npartitions=n_workers, **soundscape_config)\n            soundscape_data\
        \ = recs[recs.proc_unit == proc_unit]\n            pipeline = CronoSoundscape(name\
        \ = \"soundscape\", work_dir = WORK_DIR_PIPELINE, recordings = soundscape_data)\n\
        \            soundscape = pipeline[\"hashed_soundscape\"].compute(client=client,\
        \ feed=FEED)\n\n            # sequence\n            plot_soundscape(soundscape,\
        \ \"sequence\", SPECTRUM, FEED_metadata, file_path,\n                    \
        \        CUMULO, node, recorder, deployment, parent_id, plot_indices, MIN_FREQ_SC)\
        \    \n            # mean\n            plot_soundscape(soundscape, \"mean\"\
        , SPECTRUM, FEED_metadata, file_path, \n                            CUMULO,\
        \ node, recorder, deployment, parent_id, plot_indices, MIN_FREQ_SC)\n\n  \
        \          # standard deviation\n            plot_soundscape(soundscape, \"\
        standard_deviation\", SPECTRUM, FEED_metadata, file_path, \n             \
        \               CUMULO, node, recorder, deployment, parent_id, plot_indices,\
        \ MIN_FREQ_SC)\n\n            # save soundscape vector\n            soundscape_path\
        \ = os.path.join(file_path, \"hashed_soundscape.parquet\")\n            #\
        \ soundscape_orig_path = os.path.join(RESULTS_DIR, \"get_soundscape/persist/hashed_soundscape.parquet\"\
        ) \n            soundscape_orig_path = '/shared_volume/audio/soundscape/persist/hashed_soundscape.parquet'\n\
        \            shutil.move(soundscape_orig_path,soundscape_path)\n         \
        \   save_metadata(parent_id, \"soundscape\", SPECTRUM, FEED_metadata, file_path,\n\
        \                          CUMULO, node, recorder, deployment)\n         \
        \   shutil.rmtree('/shared_volume/audio/soundscape')\n\n        except:\n\
        \            pass\n        # restart client\n        client.restart()\n\n\
        \    # total time\n    execution_info[\"time_compute_soundscapes\"] = str(timedelta(seconds=time.monotonic()\
        \ - start_time_compute_soundscapes))\n\n    client.close()\n    cluster.close()\n\
        \n    # remove empty subdirectories\n    remove_empty_folders(RESULTS_DIR)\n\
        \n    # execution info\n\n    # arch info\n    arch_info_dict = {}\n    arch_info\
        \ = subprocess.check_output(\"lscpu\", shell=True).strip().decode().split(\"\
        \\\\n\")[:-1]\n    arch_info = [x.replace(\" \", \"\") for x in arch_info]\n\
        \n    for field in arch_info:\n        key, value = field.split(\":\")\n \
        \       arch_info_dict[key] = value\n    arch_info_dict[\"RAM Memory (GB)\"\
        ] = psutil.virtual_memory().total >> 30\n\n    execution_info[\"arch_info_dict\"\
        ] = arch_info_dict\n\n    # save\n    execution_path = os.path.join(RESULTS_DIR,\
        \ \"execution_info.json\")\n\n    if os.path.exists(execution_path):\n   \
        \     os.remove(execution_path)\n    with open(execution_path, 'w', encoding='utf-8')\
        \ as f:\n        json.dump(execution_info, f, ensure_ascii=False, indent=4)\n\
        \n    '''\n\n    # run the code blocks inside a jupyter kernel\n    from kale.common.jputils\
        \ import run_code as _kale_run_code\n    from kale.common.kfputils import\
        \ \\\n        update_uimetadata as _kale_update_uimetadata\n    _kale_blocks\
        \ = (_kale_pipeline_parameters_block, _kale_data_loading_block,\n        \
        \            _kale_block1,\n                    _kale_block2,\n          \
        \          _kale_block3,\n                    )\n    _kale_html_artifact =\
        \ _kale_run_code(_kale_blocks)\n    with open(\"/compute_soundscapes.html\"\
        , \"w\") as f:\n        f.write(_kale_html_artifact)\n    _kale_update_uimetadata('compute_soundscapes')\n\
        \n    _kale_mlmdutils.call(\"mark_execution_complete\")\n\nimport argparse\n\
        _parser = argparse.ArgumentParser(prog='Compute soundscapes', description='')\n\
        _parser.add_argument(\"--BLUE-IDX\", dest=\"BLUE_IDX\", type=str, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--CUMULO\", dest=\"CUMULO\"\
        , type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --FREQUENCY-BINS\", dest=\"FREQUENCY_BINS\", type=int, required=True, default=argparse.SUPPRESS)\n\
        _parser.add_argument(\"--FREQUENCY-LIMITS-LB\", dest=\"FREQUENCY_LIMITS_LB\"\
        , type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --FREQUENCY-LIMITS-UB\", dest=\"FREQUENCY_LIMITS_UB\", type=int, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--GREEN-IDX\", dest=\"\
        GREEN_IDX\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --HASHER-TIME-MODULE\", dest=\"HASHER_TIME_MODULE\", type=int, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--HASHER-TIME-UNIT\"\
        , dest=\"HASHER_TIME_UNIT\", type=int, required=True, default=argparse.SUPPRESS)\n\
        _parser.add_argument(\"--HASH-NAME\", dest=\"HASH_NAME\", type=str, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--MIN-FREQ-SC\", dest=\"\
        MIN_FREQ_SC\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --RED-IDX\", dest=\"RED_IDX\", type=str, required=True, default=argparse.SUPPRESS)\n\
        _parser.add_argument(\"--RESULTS-DIR\", dest=\"RESULTS_DIR\", type=str, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--SPECTRUM\", dest=\"\
        SPECTRUM\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --THREADS-PER-WORKER\", dest=\"THREADS_PER_WORKER\", type=int, required=True,\
        \ default=argparse.SUPPRESS)\n_parser.add_argument(\"--TIME-UNIT\", dest=\"\
        TIME_UNIT\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --WORK-DIR-PIPELINE\", dest=\"WORK_DIR_PIPELINE\", type=str, required=True,\
        \ default=argparse.SUPPRESS)\n_parsed_args = vars(_parser.parse_args())\n\n\
        _outputs = compute_soundscapes(**_parsed_args)\n"
      image: sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev
      securityContext: {runAsUser: 0}
      volumeMounts:
      - {mountPath: /shared_volume, name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d}
      workingDir: //shared_volume/audio
    inputs:
      parameters:
      - {name: BLUE_IDX}
      - {name: CUMULO}
      - {name: FREQUENCY_BINS}
      - {name: FREQUENCY_LIMITS_LB}
      - {name: FREQUENCY_LIMITS_UB}
      - {name: GREEN_IDX}
      - {name: HASHER_TIME_MODULE}
      - {name: HASHER_TIME_UNIT}
      - {name: HASH_NAME}
      - {name: MIN_FREQ_SC}
      - {name: RED_IDX}
      - {name: RESULTS_DIR}
      - {name: SPECTRUM}
      - {name: THREADS_PER_WORKER}
      - {name: TIME_UNIT}
      - {name: WORK_DIR_PIPELINE}
      - {name: vol_shared_volume}
    outputs:
      artifacts:
      - {name: mlpipeline-ui-metadata, path: /tmp/mlpipeline-ui-metadata.json}
      - {name: compute_soundscapes, path: /compute_soundscapes.html}
    metadata:
      annotations: {kubeflow-kale.org/dependent-templates: '["create-results-dirstruct",
          "get-audio-df"]', pipelines.kubeflow.org/component_spec: '{"implementation":
          {"container": {"args": ["--BLUE-IDX", {"inputValue": "BLUE_IDX"}, "--CUMULO",
          {"inputValue": "CUMULO"}, "--FREQUENCY-BINS", {"inputValue": "FREQUENCY_BINS"},
          "--FREQUENCY-LIMITS-LB", {"inputValue": "FREQUENCY_LIMITS_LB"}, "--FREQUENCY-LIMITS-UB",
          {"inputValue": "FREQUENCY_LIMITS_UB"}, "--GREEN-IDX", {"inputValue": "GREEN_IDX"},
          "--HASHER-TIME-MODULE", {"inputValue": "HASHER_TIME_MODULE"}, "--HASHER-TIME-UNIT",
          {"inputValue": "HASHER_TIME_UNIT"}, "--HASH-NAME", {"inputValue": "HASH_NAME"},
          "--MIN-FREQ-SC", {"inputValue": "MIN_FREQ_SC"}, "--RED-IDX", {"inputValue":
          "RED_IDX"}, "--RESULTS-DIR", {"inputValue": "RESULTS_DIR"}, "--SPECTRUM",
          {"inputValue": "SPECTRUM"}, "--THREADS-PER-WORKER", {"inputValue": "THREADS_PER_WORKER"},
          "--TIME-UNIT", {"inputValue": "TIME_UNIT"}, "--WORK-DIR-PIPELINE", {"inputValue":
          "WORK_DIR_PIPELINE"}], "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf
          \"%s\" \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n",
          "def compute_soundscapes(BLUE_IDX, CUMULO, FREQUENCY_BINS, FREQUENCY_LIMITS_LB,
          FREQUENCY_LIMITS_UB, GREEN_IDX, HASHER_TIME_MODULE, HASHER_TIME_UNIT, HASH_NAME,
          MIN_FREQ_SC, RED_IDX, RESULTS_DIR, SPECTRUM, THREADS_PER_WORKER, TIME_UNIT,
          WORK_DIR_PIPELINE):\n    _kale_pipeline_parameters_block = ''''''\n    BLUE_IDX
          = \"{}\"\n    CUMULO = {}\n    FREQUENCY_BINS = {}\n    FREQUENCY_LIMITS_LB
          = {}\n    FREQUENCY_LIMITS_UB = {}\n    GREEN_IDX = \"{}\"\n    HASHER_TIME_MODULE
          = {}\n    HASHER_TIME_UNIT = {}\n    HASH_NAME = \"{}\"\n    MIN_FREQ_SC
          = {}\n    RED_IDX = \"{}\"\n    RESULTS_DIR = \"{}\"\n    SPECTRUM = \"{}\"\n    THREADS_PER_WORKER
          = {}\n    TIME_UNIT = {}\n    WORK_DIR_PIPELINE = \"{}\"\n    ''''''.format(BLUE_IDX,
          CUMULO, FREQUENCY_BINS, FREQUENCY_LIMITS_LB, FREQUENCY_LIMITS_UB, GREEN_IDX,
          HASHER_TIME_MODULE, HASHER_TIME_UNIT, HASH_NAME, MIN_FREQ_SC, RED_IDX, RESULTS_DIR,
          SPECTRUM, THREADS_PER_WORKER, TIME_UNIT, WORK_DIR_PIPELINE)\n\n    from
          kale.common import mlmdutils as _kale_mlmdutils\n    _kale_mlmdutils.init_metadata()\n\n    _kale_data_loading_block
          = ''''''\n    # -----------------------DATA LOADING START--------------------------------\n    from
          kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\")\n    recs
          = _kale_marshal.load(\"recs\")\n    # -----------------------DATA LOADING
          END----------------------------------\n    ''''''\n\n    _kale_block1 =
          ''''''\n    import datetime\n    import hashlib\n    import json\n    import
          multiprocessing \n    import matplotlib.pyplot as plt\n    import os\n    import
          pandas as pd\n    import psutil\n    import shutil\n    import subprocess\n    import
          time\n\n    from dask.distributed import Client, LocalCluster\n    from
          datetime import timedelta\n    from dotenv import load_dotenv\n    from
          os.path import exists as file_exists\n\n    from yuntu.collection.methods
          import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n    from
          yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n    from
          yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape, HASHER_CONFIG\n    ''''''\n\n    _kale_block2
          = ''''''\n    def create_results_folder_str(results_dir, cumulo, nodes_list,
          rec_list, dep_list): \n        # results directory\n        os.makedirs(results_dir,
          exist_ok=True)\n        # cumulus subdir\n        cum_subdir = os.path.join(results_dir,
          str(cumulo))\n        os.makedirs(cum_subdir, exist_ok=True)\n        #
          node subdirs\n        for node in nodes_list:\n            node_subdir =
          os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir, exist_ok=True)\n            #
          recorder subdirs\n            for rec in rec_list:\n                rec_subdir
          = os.path.join(node_subdir, rec)\n                os.makedirs(rec_subdir,
          exist_ok=True)\n                # deployment subdirs\n                for
          dep in dep_list:\n                    dep_subdir = os.path.join(rec_subdir,
          dep)\n                    os.makedirs(dep_subdir, exist_ok=True)\n\n    def
          remove_empty_folders(path_abs):\n        walk = list(os.walk(path_abs))\n        for
          path, _, _ in walk[::-1]:\n            if len(os.listdir(path)) == 0:\n                os.rmdir(path)            \n\n    def
          save_metadata(product_id, product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=\"Null\"):\n        if product_type
          == \"soundscape\":\n            product_name = \"Soundscape\"\n            file_path
          = os.path.join(path, \"hashed_soundscape.parquet\")\n            metadata_filename
          = os.path.join(path, \"soundscape_metadata.json\")\n        elif product_type
          == \"sequence\":\n            product_name = \"Soundscape sequential plot\"\n            file_path
          = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename
          = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type
          == \"standard_deviation\":\n            product_name = \"Soundscape standard
          deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"std_soundscape_metadata.json\")\n        elif product_type
          == \"mean\":\n            product_name = \"Soundscape mean plot\"\n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"mean_soundscape_metadata.json\")\n\n        if int(node.split(\"_\")[2])
          == 0:\n            node_category = \"Degradado\"\n        elif int(node.split(\"_\")[2])
          == 1:\n            node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\":
          product_id,\n            \"product_parent\": parent,\n            \"product_name\":
          product_name,\n            \"product_configs\": sc_config,\n            \"product_path\":
          file_path,\n            \"product_spectrum\": product_spectrum,\n            \"CumulusName\":
          cumulus,\n            \"NodeCategoryIntegrity\": node_category,\n            \"NomenclatureNode\":
          node,\n            \"SerialNumber\": recorder,\n            \"DateDeployment\":
          deployment\n        }\n\n        with open(metadata_filename, ''w'', encoding=''utf-8'')
          as f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n    def
          plot_soundscape(soundscape, product_type, product_spectrum, sc_config, path,
          \n                        cumulus, node, recorder, deployment, parent, indices,
          min_freq=None,\n                      figsize=(20,15), plt_style=''ggplot''):\n\n        if
          min_freq:\n            soundscape = soundscape[soundscape[''min_freq'']<=min_freq]\n\n        if
          product_type == \"sequence\":\n            file_path = os.path.join(path,
          \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_sequence(rgb=indices,
          time_format=''%Y-%m %H:%M'', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)
          \n            plt.show()\n            # save metadata\n            save_metadata(product_id,
          product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type
          == \"standard_deviation\":\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            product_id
          = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"std\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()
          \n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)     \n\n        elif product_type == \"mean\": \n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            product_id =
          hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"mean\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)    \n\n        print(f\"File saved at {file_path}\")\n    ''''''\n\n    _kale_block3
          = ''''''\n    execution_info = {}\n    # start_time = time.monotonic()\n    start_time_compute_soundscapes
          = time.monotonic()\n    # hasher config \n    hasher_config = {''module'':
          {''object_name'': ''yuntu.soundscape.hashers.crono.CronoHasher''},\n                     ''kwargs'':
          {''time_utc_column'': ''abs_start_time''}}\n\n    hasher_config[\"kwargs\"][\"time_unit\"]
          = HASHER_TIME_UNIT\n    hasher_config[\"kwargs\"][\"time_module\"] = HASHER_TIME_MODULE\n    hasher_config[\"kwargs\"][\"start_tzone\"]
          = \"America/Mexico_City\"\n    hasher_config[\"kwargs\"][\"start_time\"]
          = DEFAULT_HASHER_CONFIG[\"start_time\"]\n    hasher_config[\"kwargs\"][\"start_format\"]
          = DEFAULT_HASHER_CONFIG[\"start_format\"]\n    hasher_config[\"kwargs\"][\"aware_start\"]
          = None\n\n    # soundscape config \n    slice_config  = dict(CronoSoundscape()[\"slice_config\"].data)\n    slice_config[\"time_unit\"]
          = TIME_UNIT\n    slice_config[\"frequency_bins\"] = FREQUENCY_BINS\n    slice_config[\"frequency_limits\"]
          = (FREQUENCY_LIMITS_LB, FREQUENCY_LIMITS_UB)\n\n    # fed configuration
          [\"TOTAL\", \"CORE\", \"TAIL\", \"INFORMATION\", \"ICOMPLEXITY\", \"EXAG\"]\n    indices
          = CronoSoundscape()[\"indices\"].data + [ICOMPLEXITY()]  + [TAIL()]\n\n    #
          dask local cluster\n    n_workers = int(0.95 * multiprocessing .cpu_count())
          \n    cluster = LocalCluster(n_workers = n_workers, \n                           threads_per_worker
          = THREADS_PER_WORKER)\n    client = Client(cluster)\n    npartitions = len(client.ncores())\n\n    #
          FEED\n    FEED = {\n        \"slice_config\": slice_config,\n        \"indices\":
          indices,\n        \"hash_name\": HASH_NAME,\n        \"hasher_config\":
          hasher_config,\n        \"npartitions\": npartitions\n    }\n\n    # adjust
          for metadata\n    indexes_computed = [\"TOTAL\", \"CORE\", \"TAIL\", \"INFORMATION\",
          \"ICOMPLEXITY\", \"EXAG\"]\n    FEED_metadata = FEED.copy()\n    FEED_metadata[\"indices\"]
          = indexes_computed\n\n    plot_indices = [RED_IDX, GREEN_IDX, BLUE_IDX]
          #rgb order\n    # soundscape per unit\n    proc_units = recs.proc_unit.unique()\n\n    for
          proc_unit in proc_units:\n        try: \n            start_soundscape =
          time.monotonic()\n            node, recorder, deployment = proc_unit\n            print(f\"*
          Processing: node {node} | recorder {recorder} | deployment date {deployment}\")\n            file_path
          = os.path.join(RESULTS_DIR, str(CUMULO), str(node), recorder, deployment)\n            parent_id
          = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n            # soundscape
          = recs[recs.proc_unit == proc_unit].audio.get_soundscape(client=client,
          npartitions=n_workers, **soundscape_config)\n            soundscape_data
          = recs[recs.proc_unit == proc_unit]\n            pipeline = CronoSoundscape(name
          = \"soundscape\", work_dir = WORK_DIR_PIPELINE, recordings = soundscape_data)\n            soundscape
          = pipeline[\"hashed_soundscape\"].compute(client=client, feed=FEED)\n\n            #
          sequence\n            plot_soundscape(soundscape, \"sequence\", SPECTRUM,
          FEED_metadata, file_path,\n                            CUMULO, node, recorder,
          deployment, parent_id, plot_indices, MIN_FREQ_SC)    \n            # mean\n            plot_soundscape(soundscape,
          \"mean\", SPECTRUM, FEED_metadata, file_path, \n                            CUMULO,
          node, recorder, deployment, parent_id, plot_indices, MIN_FREQ_SC)\n\n            #
          standard deviation\n            plot_soundscape(soundscape, \"standard_deviation\",
          SPECTRUM, FEED_metadata, file_path, \n                            CUMULO,
          node, recorder, deployment, parent_id, plot_indices, MIN_FREQ_SC)\n\n            #
          save soundscape vector\n            soundscape_path = os.path.join(file_path,
          \"hashed_soundscape.parquet\")\n            # soundscape_orig_path = os.path.join(RESULTS_DIR,
          \"get_soundscape/persist/hashed_soundscape.parquet\") \n            soundscape_orig_path
          = ''/shared_volume/audio/soundscape/persist/hashed_soundscape.parquet''\n            shutil.move(soundscape_orig_path,soundscape_path)\n            save_metadata(parent_id,
          \"soundscape\", SPECTRUM, FEED_metadata, file_path,\n                          CUMULO,
          node, recorder, deployment)\n            shutil.rmtree(''/shared_volume/audio/soundscape'')\n\n        except:\n            pass\n        #
          restart client\n        client.restart()\n\n    # total time\n    execution_info[\"time_compute_soundscapes\"]
          = str(timedelta(seconds=time.monotonic() - start_time_compute_soundscapes))\n\n    client.close()\n    cluster.close()\n\n    #
          remove empty subdirectories\n    remove_empty_folders(RESULTS_DIR)\n\n    #
          execution info\n\n    # arch info\n    arch_info_dict = {}\n    arch_info
          = subprocess.check_output(\"lscpu\", shell=True).strip().decode().split(\"\\\\n\")[:-1]\n    arch_info
          = [x.replace(\" \", \"\") for x in arch_info]\n\n    for field in arch_info:\n        key,
          value = field.split(\":\")\n        arch_info_dict[key] = value\n    arch_info_dict[\"RAM
          Memory (GB)\"] = psutil.virtual_memory().total >> 30\n\n    execution_info[\"arch_info_dict\"]
          = arch_info_dict\n\n    # save\n    execution_path = os.path.join(RESULTS_DIR,
          \"execution_info.json\")\n\n    if os.path.exists(execution_path):\n        os.remove(execution_path)\n    with
          open(execution_path, ''w'', encoding=''utf-8'') as f:\n        json.dump(execution_info,
          f, ensure_ascii=False, indent=4)\n\n    ''''''\n\n    # run the code blocks
          inside a jupyter kernel\n    from kale.common.jputils import run_code as
          _kale_run_code\n    from kale.common.kfputils import \\\n        update_uimetadata
          as _kale_update_uimetadata\n    _kale_blocks = (_kale_pipeline_parameters_block,
          _kale_data_loading_block,\n                    _kale_block1,\n                    _kale_block2,\n                    _kale_block3,\n                    )\n    _kale_html_artifact
          = _kale_run_code(_kale_blocks)\n    with open(\"/compute_soundscapes.html\",
          \"w\") as f:\n        f.write(_kale_html_artifact)\n    _kale_update_uimetadata(''compute_soundscapes'')\n\n    _kale_mlmdutils.call(\"mark_execution_complete\")\n\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Compute soundscapes'',
          description='''')\n_parser.add_argument(\"--BLUE-IDX\", dest=\"BLUE_IDX\",
          type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--CUMULO\",
          dest=\"CUMULO\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--FREQUENCY-BINS\",
          dest=\"FREQUENCY_BINS\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--FREQUENCY-LIMITS-LB\",
          dest=\"FREQUENCY_LIMITS_LB\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--FREQUENCY-LIMITS-UB\",
          dest=\"FREQUENCY_LIMITS_UB\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--GREEN-IDX\",
          dest=\"GREEN_IDX\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--HASHER-TIME-MODULE\",
          dest=\"HASHER_TIME_MODULE\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--HASHER-TIME-UNIT\",
          dest=\"HASHER_TIME_UNIT\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--HASH-NAME\",
          dest=\"HASH_NAME\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--MIN-FREQ-SC\",
          dest=\"MIN_FREQ_SC\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--RED-IDX\",
          dest=\"RED_IDX\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--RESULTS-DIR\",
          dest=\"RESULTS_DIR\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--SPECTRUM\",
          dest=\"SPECTRUM\", type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--THREADS-PER-WORKER\",
          dest=\"THREADS_PER_WORKER\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--TIME-UNIT\",
          dest=\"TIME_UNIT\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--WORK-DIR-PIPELINE\",
          dest=\"WORK_DIR_PIPELINE\", type=str, required=True, default=argparse.SUPPRESS)\n_parsed_args
          = vars(_parser.parse_args())\n\n_outputs = compute_soundscapes(**_parsed_args)\n"],
          "image": "sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev"}},
          "inputs": [{"name": "BLUE_IDX", "type": "String"}, {"name": "CUMULO", "type":
          "Integer"}, {"name": "FREQUENCY_BINS", "type": "Integer"}, {"name": "FREQUENCY_LIMITS_LB",
          "type": "Integer"}, {"name": "FREQUENCY_LIMITS_UB", "type": "Integer"},
          {"name": "GREEN_IDX", "type": "String"}, {"name": "HASHER_TIME_MODULE",
          "type": "Integer"}, {"name": "HASHER_TIME_UNIT", "type": "Integer"}, {"name":
          "HASH_NAME", "type": "String"}, {"name": "MIN_FREQ_SC", "type": "Integer"},
          {"name": "RED_IDX", "type": "String"}, {"name": "RESULTS_DIR", "type": "String"},
          {"name": "SPECTRUM", "type": "String"}, {"name": "THREADS_PER_WORKER", "type":
          "Integer"}, {"name": "TIME_UNIT", "type": "Integer"}, {"name": "WORK_DIR_PIPELINE",
          "type": "String"}], "name": "Compute soundscapes"}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"BLUE_IDX": "{{inputs.parameters.BLUE_IDX}}",
          "CUMULO": "{{inputs.parameters.CUMULO}}", "FREQUENCY_BINS": "{{inputs.parameters.FREQUENCY_BINS}}",
          "FREQUENCY_LIMITS_LB": "{{inputs.parameters.FREQUENCY_LIMITS_LB}}", "FREQUENCY_LIMITS_UB":
          "{{inputs.parameters.FREQUENCY_LIMITS_UB}}", "GREEN_IDX": "{{inputs.parameters.GREEN_IDX}}",
          "HASHER_TIME_MODULE": "{{inputs.parameters.HASHER_TIME_MODULE}}", "HASHER_TIME_UNIT":
          "{{inputs.parameters.HASHER_TIME_UNIT}}", "HASH_NAME": "{{inputs.parameters.HASH_NAME}}",
          "MIN_FREQ_SC": "{{inputs.parameters.MIN_FREQ_SC}}", "RED_IDX": "{{inputs.parameters.RED_IDX}}",
          "RESULTS_DIR": "{{inputs.parameters.RESULTS_DIR}}", "SPECTRUM": "{{inputs.parameters.SPECTRUM}}",
          "THREADS_PER_WORKER": "{{inputs.parameters.THREADS_PER_WORKER}}", "TIME_UNIT":
          "{{inputs.parameters.TIME_UNIT}}", "WORK_DIR_PIPELINE": "{{inputs.parameters.WORK_DIR_PIPELINE}}"}'}
      labels:
        pipelines.kubeflow.org/metadata_written: "true"
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.11
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
    volumes:
    - name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d
      persistentVolumeClaim: {claimName: '{{inputs.parameters.vol_shared_volume}}'}
  - name: create-results-dirstruct
    container:
      args: [--CUMULO, '{{inputs.parameters.CUMULO}}', --RESULTS-DIR, '{{inputs.parameters.RESULTS_DIR}}']
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - "def create_results_dirstruct(CUMULO, RESULTS_DIR):\n    _kale_pipeline_parameters_block\
        \ = '''\n    CUMULO = {}\n    RESULTS_DIR = \"{}\"\n    '''.format(CUMULO,\
        \ RESULTS_DIR)\n\n    from kale.common import mlmdutils as _kale_mlmdutils\n\
        \    _kale_mlmdutils.init_metadata()\n\n    _kale_data_loading_block = '''\n\
        \    # -----------------------DATA LOADING START--------------------------------\n\
        \    from kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"\
        /shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\"\
        )\n    recs = _kale_marshal.load(\"recs\")\n    # -----------------------DATA\
        \ LOADING END----------------------------------\n    '''\n\n    _kale_block1\
        \ = '''\n    import datetime\n    import hashlib\n    import json\n    import\
        \ multiprocessing \n    import matplotlib.pyplot as plt\n    import os\n \
        \   import pandas as pd\n    import psutil\n    import shutil\n    import\
        \ subprocess\n    import time\n\n    from dask.distributed import Client,\
        \ LocalCluster\n    from datetime import timedelta\n    from dotenv import\
        \ load_dotenv\n    from os.path import exists as file_exists\n\n    from yuntu.collection.methods\
        \ import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n\
        \    from yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n\
        \    from yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape,\
        \ HASHER_CONFIG\n    '''\n\n    _kale_block2 = '''\n    def create_results_folder_str(results_dir,\
        \ cumulo, nodes_list, rec_list, dep_list): \n        # results directory\n\
        \        os.makedirs(results_dir, exist_ok=True)\n        # cumulus subdir\n\
        \        cum_subdir = os.path.join(results_dir, str(cumulo))\n        os.makedirs(cum_subdir,\
        \ exist_ok=True)\n        # node subdirs\n        for node in nodes_list:\n\
        \            node_subdir = os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir,\
        \ exist_ok=True)\n            # recorder subdirs\n            for rec in rec_list:\n\
        \                rec_subdir = os.path.join(node_subdir, rec)\n           \
        \     os.makedirs(rec_subdir, exist_ok=True)\n                # deployment\
        \ subdirs\n                for dep in dep_list:\n                    dep_subdir\
        \ = os.path.join(rec_subdir, dep)\n                    os.makedirs(dep_subdir,\
        \ exist_ok=True)\n\n    def remove_empty_folders(path_abs):\n        walk\
        \ = list(os.walk(path_abs))\n        for path, _, _ in walk[::-1]:\n     \
        \       if len(os.listdir(path)) == 0:\n                os.rmdir(path)   \
        \         \n\n    def save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent=\"Null\"):\n        if product_type == \"soundscape\":\n        \
        \    product_name = \"Soundscape\"\n            file_path = os.path.join(path,\
        \ \"hashed_soundscape.parquet\")\n            metadata_filename = os.path.join(path,\
        \ \"soundscape_metadata.json\")\n        elif product_type == \"sequence\"\
        :\n            product_name = \"Soundscape sequential plot\"\n           \
        \ file_path = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename\
        \ = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type\
        \ == \"standard_deviation\":\n            product_name = \"Soundscape standard\
        \ deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"std_soundscape_metadata.json\"\
        )\n        elif product_type == \"mean\":\n            product_name = \"Soundscape\
        \ mean plot\"\n            file_path = os.path.join(path, \"mean_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"mean_soundscape_metadata.json\"\
        )\n\n        if int(node.split(\"_\")[2]) == 0:\n            node_category\
        \ = \"Degradado\"\n        elif int(node.split(\"_\")[2]) == 1:\n        \
        \    node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\"\
        : product_id,\n            \"product_parent\": parent,\n            \"product_name\"\
        : product_name,\n            \"product_configs\": sc_config,\n           \
        \ \"product_path\": file_path,\n            \"product_spectrum\": product_spectrum,\n\
        \            \"CumulusName\": cumulus,\n            \"NodeCategoryIntegrity\"\
        : node_category,\n            \"NomenclatureNode\": node,\n            \"\
        SerialNumber\": recorder,\n            \"DateDeployment\": deployment\n  \
        \      }\n\n        with open(metadata_filename, 'w', encoding='utf-8') as\
        \ f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n\
        \    def plot_soundscape(soundscape, product_type, product_spectrum, sc_config,\
        \ path, \n                        cumulus, node, recorder, deployment, parent,\
        \ indices, min_freq=None,\n                      figsize=(20,15), plt_style='ggplot'):\n\
        \n        if min_freq:\n            soundscape = soundscape[soundscape['min_freq']<=min_freq]\n\
        \n        if product_type == \"sequence\":\n            file_path = os.path.join(path,\
        \ \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_sequence(rgb=indices, time_format='%Y-%m\
        \ %H:%M', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n\
        \            plt.tight_layout()\n            plt.savefig(file_path) \n   \
        \         plt.show()\n            # save metadata\n            save_metadata(product_id,\
        \ product_type, product_spectrum, sc_config,\n                      path,\
        \ cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type\
        \ == \"standard_deviation\":\n            file_path = os.path.join(path, \"\
        std_soundscape.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"std\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\
        \ \n            plt.savefig(file_path)\n            plt.show()\n\n       \
        \     # save metadata\n            save_metadata(product_id, product_type,\
        \ product_spectrum, sc_config,\n                      path, cumulus, node,\
        \ recorder, deployment, parent)     \n\n        elif product_type == \"mean\"\
        : \n            file_path = os.path.join(path, \"mean_soundscape.png\")\n\
        \            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"mean\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n\
        \            plt.savefig(file_path)\n            plt.show()\n\n          \
        \  # save metadata\n            save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent)    \n\n        print(f\"File saved at {file_path}\")\n    '''\n\n\
        \    _kale_block3 = '''\n    nodes_list = recs.node.unique()\n    recorders_list\
        \ = recs.recorder.unique()\n    deployments_list = recs.deployment.unique()\n\
        \    if os.path.isdir(RESULTS_DIR):\n        shutil.rmtree(RESULTS_DIR)\n\
        \    create_results_folder_str(RESULTS_DIR, CUMULO, nodes_list, recorders_list,\
        \ deployments_list)\n    '''\n\n    _kale_data_saving_block = '''\n    # -----------------------DATA\
        \ SAVING START---------------------------------\n    from kale import marshal\
        \ as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\"\
        )\n    _kale_marshal.save(recs, \"recs\")\n    # -----------------------DATA\
        \ SAVING END-----------------------------------\n    '''\n\n    # run the\
        \ code blocks inside a jupyter kernel\n    from kale.common.jputils import\
        \ run_code as _kale_run_code\n    from kale.common.kfputils import \\\n  \
        \      update_uimetadata as _kale_update_uimetadata\n    _kale_blocks = (_kale_pipeline_parameters_block,\
        \ _kale_data_loading_block,\n                    _kale_block1,\n         \
        \           _kale_block2,\n                    _kale_block3,\n           \
        \         _kale_data_saving_block)\n    _kale_html_artifact = _kale_run_code(_kale_blocks)\n\
        \    with open(\"/create_results_dirstruct.html\", \"w\") as f:\n        f.write(_kale_html_artifact)\n\
        \    _kale_update_uimetadata('create_results_dirstruct')\n\n    _kale_mlmdutils.call(\"\
        mark_execution_complete\")\n\nimport argparse\n_parser = argparse.ArgumentParser(prog='Create\
        \ results dirstruct', description='')\n_parser.add_argument(\"--CUMULO\",\
        \ dest=\"CUMULO\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --RESULTS-DIR\", dest=\"RESULTS_DIR\", type=str, required=True, default=argparse.SUPPRESS)\n\
        _parsed_args = vars(_parser.parse_args())\n\n_outputs = create_results_dirstruct(**_parsed_args)\n"
      image: sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev
      securityContext: {runAsUser: 0}
      volumeMounts:
      - {mountPath: /shared_volume, name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d}
      workingDir: //shared_volume/audio
    inputs:
      parameters:
      - {name: CUMULO}
      - {name: RESULTS_DIR}
      - {name: vol_shared_volume}
    outputs:
      artifacts:
      - {name: mlpipeline-ui-metadata, path: /tmp/mlpipeline-ui-metadata.json}
      - {name: create_results_dirstruct, path: /create_results_dirstruct.html}
    metadata:
      annotations: {kubeflow-kale.org/dependent-templates: '["get-audio-df"]', pipelines.kubeflow.org/component_spec: '{"implementation":
          {"container": {"args": ["--CUMULO", {"inputValue": "CUMULO"}, "--RESULTS-DIR",
          {"inputValue": "RESULTS_DIR"}], "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf
          \"%s\" \"$0\" > \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n",
          "def create_results_dirstruct(CUMULO, RESULTS_DIR):\n    _kale_pipeline_parameters_block
          = ''''''\n    CUMULO = {}\n    RESULTS_DIR = \"{}\"\n    ''''''.format(CUMULO,
          RESULTS_DIR)\n\n    from kale.common import mlmdutils as _kale_mlmdutils\n    _kale_mlmdutils.init_metadata()\n\n    _kale_data_loading_block
          = ''''''\n    # -----------------------DATA LOADING START--------------------------------\n    from
          kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\")\n    recs
          = _kale_marshal.load(\"recs\")\n    # -----------------------DATA LOADING
          END----------------------------------\n    ''''''\n\n    _kale_block1 =
          ''''''\n    import datetime\n    import hashlib\n    import json\n    import
          multiprocessing \n    import matplotlib.pyplot as plt\n    import os\n    import
          pandas as pd\n    import psutil\n    import shutil\n    import subprocess\n    import
          time\n\n    from dask.distributed import Client, LocalCluster\n    from
          datetime import timedelta\n    from dotenv import load_dotenv\n    from
          os.path import exists as file_exists\n\n    from yuntu.collection.methods
          import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n    from
          yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n    from
          yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape, HASHER_CONFIG\n    ''''''\n\n    _kale_block2
          = ''''''\n    def create_results_folder_str(results_dir, cumulo, nodes_list,
          rec_list, dep_list): \n        # results directory\n        os.makedirs(results_dir,
          exist_ok=True)\n        # cumulus subdir\n        cum_subdir = os.path.join(results_dir,
          str(cumulo))\n        os.makedirs(cum_subdir, exist_ok=True)\n        #
          node subdirs\n        for node in nodes_list:\n            node_subdir =
          os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir, exist_ok=True)\n            #
          recorder subdirs\n            for rec in rec_list:\n                rec_subdir
          = os.path.join(node_subdir, rec)\n                os.makedirs(rec_subdir,
          exist_ok=True)\n                # deployment subdirs\n                for
          dep in dep_list:\n                    dep_subdir = os.path.join(rec_subdir,
          dep)\n                    os.makedirs(dep_subdir, exist_ok=True)\n\n    def
          remove_empty_folders(path_abs):\n        walk = list(os.walk(path_abs))\n        for
          path, _, _ in walk[::-1]:\n            if len(os.listdir(path)) == 0:\n                os.rmdir(path)            \n\n    def
          save_metadata(product_id, product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=\"Null\"):\n        if product_type
          == \"soundscape\":\n            product_name = \"Soundscape\"\n            file_path
          = os.path.join(path, \"hashed_soundscape.parquet\")\n            metadata_filename
          = os.path.join(path, \"soundscape_metadata.json\")\n        elif product_type
          == \"sequence\":\n            product_name = \"Soundscape sequential plot\"\n            file_path
          = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename
          = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type
          == \"standard_deviation\":\n            product_name = \"Soundscape standard
          deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"std_soundscape_metadata.json\")\n        elif product_type
          == \"mean\":\n            product_name = \"Soundscape mean plot\"\n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"mean_soundscape_metadata.json\")\n\n        if int(node.split(\"_\")[2])
          == 0:\n            node_category = \"Degradado\"\n        elif int(node.split(\"_\")[2])
          == 1:\n            node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\":
          product_id,\n            \"product_parent\": parent,\n            \"product_name\":
          product_name,\n            \"product_configs\": sc_config,\n            \"product_path\":
          file_path,\n            \"product_spectrum\": product_spectrum,\n            \"CumulusName\":
          cumulus,\n            \"NodeCategoryIntegrity\": node_category,\n            \"NomenclatureNode\":
          node,\n            \"SerialNumber\": recorder,\n            \"DateDeployment\":
          deployment\n        }\n\n        with open(metadata_filename, ''w'', encoding=''utf-8'')
          as f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n    def
          plot_soundscape(soundscape, product_type, product_spectrum, sc_config, path,
          \n                        cumulus, node, recorder, deployment, parent, indices,
          min_freq=None,\n                      figsize=(20,15), plt_style=''ggplot''):\n\n        if
          min_freq:\n            soundscape = soundscape[soundscape[''min_freq'']<=min_freq]\n\n        if
          product_type == \"sequence\":\n            file_path = os.path.join(path,
          \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_sequence(rgb=indices,
          time_format=''%Y-%m %H:%M'', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)
          \n            plt.show()\n            # save metadata\n            save_metadata(product_id,
          product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type
          == \"standard_deviation\":\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            product_id
          = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"std\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()
          \n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)     \n\n        elif product_type == \"mean\": \n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            product_id =
          hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"mean\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)    \n\n        print(f\"File saved at {file_path}\")\n    ''''''\n\n    _kale_block3
          = ''''''\n    nodes_list = recs.node.unique()\n    recorders_list = recs.recorder.unique()\n    deployments_list
          = recs.deployment.unique()\n    if os.path.isdir(RESULTS_DIR):\n        shutil.rmtree(RESULTS_DIR)\n    create_results_folder_str(RESULTS_DIR,
          CUMULO, nodes_list, recorders_list, deployments_list)\n    ''''''\n\n    _kale_data_saving_block
          = ''''''\n    # -----------------------DATA SAVING START---------------------------------\n    from
          kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\")\n    _kale_marshal.save(recs,
          \"recs\")\n    # -----------------------DATA SAVING END-----------------------------------\n    ''''''\n\n    #
          run the code blocks inside a jupyter kernel\n    from kale.common.jputils
          import run_code as _kale_run_code\n    from kale.common.kfputils import
          \\\n        update_uimetadata as _kale_update_uimetadata\n    _kale_blocks
          = (_kale_pipeline_parameters_block, _kale_data_loading_block,\n                    _kale_block1,\n                    _kale_block2,\n                    _kale_block3,\n                    _kale_data_saving_block)\n    _kale_html_artifact
          = _kale_run_code(_kale_blocks)\n    with open(\"/create_results_dirstruct.html\",
          \"w\") as f:\n        f.write(_kale_html_artifact)\n    _kale_update_uimetadata(''create_results_dirstruct'')\n\n    _kale_mlmdutils.call(\"mark_execution_complete\")\n\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Create results dirstruct'',
          description='''')\n_parser.add_argument(\"--CUMULO\", dest=\"CUMULO\", type=int,
          required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--RESULTS-DIR\",
          dest=\"RESULTS_DIR\", type=str, required=True, default=argparse.SUPPRESS)\n_parsed_args
          = vars(_parser.parse_args())\n\n_outputs = create_results_dirstruct(**_parsed_args)\n"],
          "image": "sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev"}},
          "inputs": [{"name": "CUMULO", "type": "Integer"}, {"name": "RESULTS_DIR",
          "type": "String"}], "name": "Create results dirstruct"}', pipelines.kubeflow.org/component_ref: '{}',
        pipelines.kubeflow.org/arguments.parameters: '{"CUMULO": "{{inputs.parameters.CUMULO}}",
          "RESULTS_DIR": "{{inputs.parameters.RESULTS_DIR}}"}'}
      labels:
        pipelines.kubeflow.org/metadata_written: "true"
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.11
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
    volumes:
    - name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d
      persistentVolumeClaim: {claimName: '{{inputs.parameters.vol_shared_volume}}'}
  - name: get-audio-df
    container:
      args: [--CUMULO, '{{inputs.parameters.CUMULO}}', --PAGESIZE, '{{inputs.parameters.PAGESIZE}}',
        --SAMPLERATE, '{{inputs.parameters.SAMPLERATE}}']
      command:
      - sh
      - -ec
      - |
        program_path=$(mktemp)
        printf "%s" "$0" > "$program_path"
        python3 -u "$program_path" "$@"
      - "def get_audio_df(CUMULO, PAGESIZE, SAMPLERATE):\n    _kale_pipeline_parameters_block\
        \ = '''\n    CUMULO = {}\n    PAGESIZE = {}\n    SAMPLERATE = {}\n    '''.format(CUMULO,\
        \ PAGESIZE, SAMPLERATE)\n\n    from kale.common import mlmdutils as _kale_mlmdutils\n\
        \    _kale_mlmdutils.init_metadata()\n\n    _kale_block1 = '''\n    import\
        \ datetime\n    import hashlib\n    import json\n    import multiprocessing\
        \ \n    import matplotlib.pyplot as plt\n    import os\n    import pandas\
        \ as pd\n    import psutil\n    import shutil\n    import subprocess\n   \
        \ import time\n\n    from dask.distributed import Client, LocalCluster\n \
        \   from datetime import timedelta\n    from dotenv import load_dotenv\n \
        \   from os.path import exists as file_exists\n\n    from yuntu.collection.methods\
        \ import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n\
        \    from yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n\
        \    from yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape,\
        \ HASHER_CONFIG\n    '''\n\n    _kale_block2 = '''\n    def create_results_folder_str(results_dir,\
        \ cumulo, nodes_list, rec_list, dep_list): \n        # results directory\n\
        \        os.makedirs(results_dir, exist_ok=True)\n        # cumulus subdir\n\
        \        cum_subdir = os.path.join(results_dir, str(cumulo))\n        os.makedirs(cum_subdir,\
        \ exist_ok=True)\n        # node subdirs\n        for node in nodes_list:\n\
        \            node_subdir = os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir,\
        \ exist_ok=True)\n            # recorder subdirs\n            for rec in rec_list:\n\
        \                rec_subdir = os.path.join(node_subdir, rec)\n           \
        \     os.makedirs(rec_subdir, exist_ok=True)\n                # deployment\
        \ subdirs\n                for dep in dep_list:\n                    dep_subdir\
        \ = os.path.join(rec_subdir, dep)\n                    os.makedirs(dep_subdir,\
        \ exist_ok=True)\n\n    def remove_empty_folders(path_abs):\n        walk\
        \ = list(os.walk(path_abs))\n        for path, _, _ in walk[::-1]:\n     \
        \       if len(os.listdir(path)) == 0:\n                os.rmdir(path)   \
        \         \n\n    def save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent=\"Null\"):\n        if product_type == \"soundscape\":\n        \
        \    product_name = \"Soundscape\"\n            file_path = os.path.join(path,\
        \ \"hashed_soundscape.parquet\")\n            metadata_filename = os.path.join(path,\
        \ \"soundscape_metadata.json\")\n        elif product_type == \"sequence\"\
        :\n            product_name = \"Soundscape sequential plot\"\n           \
        \ file_path = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename\
        \ = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type\
        \ == \"standard_deviation\":\n            product_name = \"Soundscape standard\
        \ deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"std_soundscape_metadata.json\"\
        )\n        elif product_type == \"mean\":\n            product_name = \"Soundscape\
        \ mean plot\"\n            file_path = os.path.join(path, \"mean_soundscape.png\"\
        )\n            metadata_filename = os.path.join(path, \"mean_soundscape_metadata.json\"\
        )\n\n        if int(node.split(\"_\")[2]) == 0:\n            node_category\
        \ = \"Degradado\"\n        elif int(node.split(\"_\")[2]) == 1:\n        \
        \    node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\"\
        : product_id,\n            \"product_parent\": parent,\n            \"product_name\"\
        : product_name,\n            \"product_configs\": sc_config,\n           \
        \ \"product_path\": file_path,\n            \"product_spectrum\": product_spectrum,\n\
        \            \"CumulusName\": cumulus,\n            \"NodeCategoryIntegrity\"\
        : node_category,\n            \"NomenclatureNode\": node,\n            \"\
        SerialNumber\": recorder,\n            \"DateDeployment\": deployment\n  \
        \      }\n\n        with open(metadata_filename, 'w', encoding='utf-8') as\
        \ f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n\
        \    def plot_soundscape(soundscape, product_type, product_spectrum, sc_config,\
        \ path, \n                        cumulus, node, recorder, deployment, parent,\
        \ indices, min_freq=None,\n                      figsize=(20,15), plt_style='ggplot'):\n\
        \n        if min_freq:\n            soundscape = soundscape[soundscape['min_freq']<=min_freq]\n\
        \n        if product_type == \"sequence\":\n            file_path = os.path.join(path,\
        \ \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_sequence(rgb=indices, time_format='%Y-%m\
        \ %H:%M', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n\
        \            plt.tight_layout()\n            plt.savefig(file_path) \n   \
        \         plt.show()\n            # save metadata\n            save_metadata(product_id,\
        \ product_type, product_spectrum, sc_config,\n                      path,\
        \ cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type\
        \ == \"standard_deviation\":\n            file_path = os.path.join(path, \"\
        std_soundscape.png\")\n            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"std\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\
        \ \n            plt.savefig(file_path)\n            plt.show()\n\n       \
        \     # save metadata\n            save_metadata(product_id, product_type,\
        \ product_spectrum, sc_config,\n                      path, cumulus, node,\
        \ recorder, deployment, parent)     \n\n        elif product_type == \"mean\"\
        : \n            file_path = os.path.join(path, \"mean_soundscape.png\")\n\
        \            product_id = hashlib.md5(file_path.encode('utf-8')).hexdigest()\n\
        \n            plt.style.use(plt_style)\n            fig, ax = plt.subplots(figsize=figsize)\n\
        \            soundscape.sndscape.plot_cycle(rgb=indices, aggr=\"mean\", time_format='%H:%M',\
        \ \n                                           xticks=24, ax=ax)\n       \
        \     plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n\
        \            plt.savefig(file_path)\n            plt.show()\n\n          \
        \  # save metadata\n            save_metadata(product_id, product_type, product_spectrum,\
        \ sc_config,\n                      path, cumulus, node, recorder, deployment,\
        \ parent)    \n\n        print(f\"File saved at {file_path}\")\n    '''\n\n\
        \    _kale_block3 = '''\n    # start_time_get_audio_df = time.monotonic()\n\
        \n    load_dotenv()\n    DB_CONFIG = {\n        'provider': 'alfresco',\n\
        \        'config': {\n            'api_url': 'https://api.conabio.gob.mx',\n\
        \            'page_size': PAGESIZE,\n            'api_key': os.getenv(\"X_API_KEY\"\
        ),\n            'base_filter': \"+TYPE: \\\\\"sipecamAudio:audiofileSipecam\\\
        \\\"\",\n            'recording_parser': {\"path\": \"/shared_volume/audio/utils.py\"\
        ,\n                                 \"object_name\": \"parser\"}\n       \
        \ }\n    }\n\n    COL_CONFIG = {\n        \"col_type\": \"alfresco\",\n  \
        \      \"db_config\": DB_CONFIG\n    }\n\n    col = collection(**COL_CONFIG)\n\
        \    query = f\"(sipecam:CumulusName:\\\\\"{CUMULO}\\\\\") AND (sipecamAudio:SampleRate:{SAMPLERATE})\"\
        \n    recs = col.get_recording_dataframe(with_metadata = True, with_geometry\
        \ = False)\n    # include add columns\n    recs.loc[:, \"node\"] = recs.metadata.apply(lambda\
        \ x: x[\"entry\"][\"properties\"][\"sipecam:NomenclatureNode\"])\n    recs.loc[:,\
        \ \"recorder\"] = recs.metadata.apply(lambda x: x[\"entry\"][\"properties\"\
        ][\"sipecamAudio:SerialNumber\"]) \n    recs.loc[:, \"deployment\"] = recs.metadata.apply(lambda\
        \ x: x[\"entry\"][\"path\"][\"name\"].split(\"/audio\")[0].split(\"/\")[-1])\n\
        \    recs.loc[:,\"proc_unit\"] = recs.apply(lambda x: (x[\"node\"], x[\"recorder\"\
        ], x[\"deployment\"]), axis=1)\n\n    # execution_info[\"time_get_audio_df\"\
        ] = str(timedelta(seconds=time.monotonic() - start_time_get_audio_df))\n \
        \   '''\n\n    _kale_data_saving_block = '''\n    # -----------------------DATA\
        \ SAVING START---------------------------------\n    from kale import marshal\
        \ as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\"\
        )\n    _kale_marshal.save(recs, \"recs\")\n    # -----------------------DATA\
        \ SAVING END-----------------------------------\n    '''\n\n    # run the\
        \ code blocks inside a jupyter kernel\n    from kale.common.jputils import\
        \ run_code as _kale_run_code\n    from kale.common.kfputils import \\\n  \
        \      update_uimetadata as _kale_update_uimetadata\n    _kale_blocks = (_kale_pipeline_parameters_block,\n\
        \                    _kale_block1,\n                    _kale_block2,\n  \
        \                  _kale_block3,\n                    _kale_data_saving_block)\n\
        \    _kale_html_artifact = _kale_run_code(_kale_blocks)\n    with open(\"\
        /get_audio_df.html\", \"w\") as f:\n        f.write(_kale_html_artifact)\n\
        \    _kale_update_uimetadata('get_audio_df')\n\n    _kale_mlmdutils.call(\"\
        mark_execution_complete\")\n\nimport argparse\n_parser = argparse.ArgumentParser(prog='Get\
        \ audio df', description='')\n_parser.add_argument(\"--CUMULO\", dest=\"CUMULO\"\
        , type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
        --PAGESIZE\", dest=\"PAGESIZE\", type=int, required=True, default=argparse.SUPPRESS)\n\
        _parser.add_argument(\"--SAMPLERATE\", dest=\"SAMPLERATE\", type=float, required=True,\
        \ default=argparse.SUPPRESS)\n_parsed_args = vars(_parser.parse_args())\n\n\
        _outputs = get_audio_df(**_parsed_args)\n"
      image: sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev
      securityContext: {runAsUser: 0}
      volumeMounts:
      - {mountPath: /shared_volume, name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d}
      workingDir: //shared_volume/audio
    inputs:
      parameters:
      - {name: CUMULO}
      - {name: PAGESIZE}
      - {name: SAMPLERATE}
      - {name: vol_shared_volume}
    outputs:
      artifacts:
      - {name: mlpipeline-ui-metadata, path: /tmp/mlpipeline-ui-metadata.json}
      - {name: get_audio_df, path: /get_audio_df.html}
    metadata:
      annotations: {kubeflow-kale.org/dependent-templates: '[]', pipelines.kubeflow.org/component_spec: '{"implementation":
          {"container": {"args": ["--CUMULO", {"inputValue": "CUMULO"}, "--PAGESIZE",
          {"inputValue": "PAGESIZE"}, "--SAMPLERATE", {"inputValue": "SAMPLERATE"}],
          "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\" >
          \"$program_path\"\npython3 -u \"$program_path\" \"$@\"\n", "def get_audio_df(CUMULO,
          PAGESIZE, SAMPLERATE):\n    _kale_pipeline_parameters_block = ''''''\n    CUMULO
          = {}\n    PAGESIZE = {}\n    SAMPLERATE = {}\n    ''''''.format(CUMULO,
          PAGESIZE, SAMPLERATE)\n\n    from kale.common import mlmdutils as _kale_mlmdutils\n    _kale_mlmdutils.init_metadata()\n\n    _kale_block1
          = ''''''\n    import datetime\n    import hashlib\n    import json\n    import
          multiprocessing \n    import matplotlib.pyplot as plt\n    import os\n    import
          pandas as pd\n    import psutil\n    import shutil\n    import subprocess\n    import
          time\n\n    from dask.distributed import Client, LocalCluster\n    from
          datetime import timedelta\n    from dotenv import load_dotenv\n    from
          os.path import exists as file_exists\n\n    from yuntu.collection.methods
          import collection\n    from yuntu.soundscape.hashers.crono import DEFAULT_HASHER_CONFIG\n    from
          yuntu.soundscape.processors.indices.direct import ICOMPLEXITY, TAIL\n    from
          yuntu.soundscape.pipelines.build_soundscape import CronoSoundscape, HASHER_CONFIG\n    ''''''\n\n    _kale_block2
          = ''''''\n    def create_results_folder_str(results_dir, cumulo, nodes_list,
          rec_list, dep_list): \n        # results directory\n        os.makedirs(results_dir,
          exist_ok=True)\n        # cumulus subdir\n        cum_subdir = os.path.join(results_dir,
          str(cumulo))\n        os.makedirs(cum_subdir, exist_ok=True)\n        #
          node subdirs\n        for node in nodes_list:\n            node_subdir =
          os.path.join(cum_subdir, node)\n            os.makedirs(node_subdir, exist_ok=True)\n            #
          recorder subdirs\n            for rec in rec_list:\n                rec_subdir
          = os.path.join(node_subdir, rec)\n                os.makedirs(rec_subdir,
          exist_ok=True)\n                # deployment subdirs\n                for
          dep in dep_list:\n                    dep_subdir = os.path.join(rec_subdir,
          dep)\n                    os.makedirs(dep_subdir, exist_ok=True)\n\n    def
          remove_empty_folders(path_abs):\n        walk = list(os.walk(path_abs))\n        for
          path, _, _ in walk[::-1]:\n            if len(os.listdir(path)) == 0:\n                os.rmdir(path)            \n\n    def
          save_metadata(product_id, product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=\"Null\"):\n        if product_type
          == \"soundscape\":\n            product_name = \"Soundscape\"\n            file_path
          = os.path.join(path, \"hashed_soundscape.parquet\")\n            metadata_filename
          = os.path.join(path, \"soundscape_metadata.json\")\n        elif product_type
          == \"sequence\":\n            product_name = \"Soundscape sequential plot\"\n            file_path
          = os.path.join(path, \"soundscape_seq.png\")\n            metadata_filename
          = os.path.join(path, \"soundscape_seq_metadata.json\")\n        elif product_type
          == \"standard_deviation\":\n            product_name = \"Soundscape standard
          deviation plot\"\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"std_soundscape_metadata.json\")\n        elif product_type
          == \"mean\":\n            product_name = \"Soundscape mean plot\"\n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            metadata_filename
          = os.path.join(path, \"mean_soundscape_metadata.json\")\n\n        if int(node.split(\"_\")[2])
          == 0:\n            node_category = \"Degradado\"\n        elif int(node.split(\"_\")[2])
          == 1:\n            node_category = \"Integro\"\n\n        metadata = {\n            \"product_id\":
          product_id,\n            \"product_parent\": parent,\n            \"product_name\":
          product_name,\n            \"product_configs\": sc_config,\n            \"product_path\":
          file_path,\n            \"product_spectrum\": product_spectrum,\n            \"CumulusName\":
          cumulus,\n            \"NodeCategoryIntegrity\": node_category,\n            \"NomenclatureNode\":
          node,\n            \"SerialNumber\": recorder,\n            \"DateDeployment\":
          deployment\n        }\n\n        with open(metadata_filename, ''w'', encoding=''utf-8'')
          as f:\n            json.dump(metadata, f, ensure_ascii=False, indent=4)\n\n    def
          plot_soundscape(soundscape, product_type, product_spectrum, sc_config, path,
          \n                        cumulus, node, recorder, deployment, parent, indices,
          min_freq=None,\n                      figsize=(20,15), plt_style=''ggplot''):\n\n        if
          min_freq:\n            soundscape = soundscape[soundscape[''min_freq'']<=min_freq]\n\n        if
          product_type == \"sequence\":\n            file_path = os.path.join(path,
          \"sequence.png\")\n            product_id = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_sequence(rgb=indices,
          time_format=''%Y-%m %H:%M'', ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)
          \n            plt.show()\n            # save metadata\n            save_metadata(product_id,
          product_type, product_spectrum, sc_config,\n                      path,
          cumulus, node, recorder, deployment, parent=parent)\n\n        elif product_type
          == \"standard_deviation\":\n            file_path = os.path.join(path, \"std_soundscape.png\")\n            product_id
          = hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"std\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()
          \n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)     \n\n        elif product_type == \"mean\": \n            file_path
          = os.path.join(path, \"mean_soundscape.png\")\n            product_id =
          hashlib.md5(file_path.encode(''utf-8'')).hexdigest()\n\n            plt.style.use(plt_style)\n            fig,
          ax = plt.subplots(figsize=figsize)\n            soundscape.sndscape.plot_cycle(rgb=indices,
          aggr=\"mean\", time_format=''%H:%M'', \n                                           xticks=24,
          ax=ax)\n            plt.xticks(rotation = 90)\n            ax.grid(False)\n            plt.tight_layout()\n            plt.savefig(file_path)\n            plt.show()\n\n            #
          save metadata\n            save_metadata(product_id, product_type, product_spectrum,
          sc_config,\n                      path, cumulus, node, recorder, deployment,
          parent)    \n\n        print(f\"File saved at {file_path}\")\n    ''''''\n\n    _kale_block3
          = ''''''\n    # start_time_get_audio_df = time.monotonic()\n\n    load_dotenv()\n    DB_CONFIG
          = {\n        ''provider'': ''alfresco'',\n        ''config'': {\n            ''api_url'':
          ''https://api.conabio.gob.mx'',\n            ''page_size'': PAGESIZE,\n            ''api_key'':
          os.getenv(\"X_API_KEY\"),\n            ''base_filter'': \"+TYPE: \\\\\"sipecamAudio:audiofileSipecam\\\\\"\",\n            ''recording_parser'':
          {\"path\": \"/shared_volume/audio/utils.py\",\n                                 \"object_name\":
          \"parser\"}\n        }\n    }\n\n    COL_CONFIG = {\n        \"col_type\":
          \"alfresco\",\n        \"db_config\": DB_CONFIG\n    }\n\n    col = collection(**COL_CONFIG)\n    query
          = f\"(sipecam:CumulusName:\\\\\"{CUMULO}\\\\\") AND (sipecamAudio:SampleRate:{SAMPLERATE})\"\n    recs
          = col.get_recording_dataframe(with_metadata = True, with_geometry = False)\n    #
          include add columns\n    recs.loc[:, \"node\"] = recs.metadata.apply(lambda
          x: x[\"entry\"][\"properties\"][\"sipecam:NomenclatureNode\"])\n    recs.loc[:,
          \"recorder\"] = recs.metadata.apply(lambda x: x[\"entry\"][\"properties\"][\"sipecamAudio:SerialNumber\"])
          \n    recs.loc[:, \"deployment\"] = recs.metadata.apply(lambda x: x[\"entry\"][\"path\"][\"name\"].split(\"/audio\")[0].split(\"/\")[-1])\n    recs.loc[:,\"proc_unit\"]
          = recs.apply(lambda x: (x[\"node\"], x[\"recorder\"], x[\"deployment\"]),
          axis=1)\n\n    # execution_info[\"time_get_audio_df\"] = str(timedelta(seconds=time.monotonic()
          - start_time_get_audio_df))\n    ''''''\n\n    _kale_data_saving_block =
          ''''''\n    # -----------------------DATA SAVING START---------------------------------\n    from
          kale import marshal as _kale_marshal\n    _kale_marshal.set_data_dir(\"/shared_volume/audio/.soundscape-sipecam-alfresco-dask-indices.ipynb.kale.marshal.dir\")\n    _kale_marshal.save(recs,
          \"recs\")\n    # -----------------------DATA SAVING END-----------------------------------\n    ''''''\n\n    #
          run the code blocks inside a jupyter kernel\n    from kale.common.jputils
          import run_code as _kale_run_code\n    from kale.common.kfputils import
          \\\n        update_uimetadata as _kale_update_uimetadata\n    _kale_blocks
          = (_kale_pipeline_parameters_block,\n                    _kale_block1,\n                    _kale_block2,\n                    _kale_block3,\n                    _kale_data_saving_block)\n    _kale_html_artifact
          = _kale_run_code(_kale_blocks)\n    with open(\"/get_audio_df.html\", \"w\")
          as f:\n        f.write(_kale_html_artifact)\n    _kale_update_uimetadata(''get_audio_df'')\n\n    _kale_mlmdutils.call(\"mark_execution_complete\")\n\nimport
          argparse\n_parser = argparse.ArgumentParser(prog=''Get audio df'', description='''')\n_parser.add_argument(\"--CUMULO\",
          dest=\"CUMULO\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--PAGESIZE\",
          dest=\"PAGESIZE\", type=int, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--SAMPLERATE\",
          dest=\"SAMPLERATE\", type=float, required=True, default=argparse.SUPPRESS)\n_parsed_args
          = vars(_parser.parse_args())\n\n_outputs = get_audio_df(**_parsed_args)\n"],
          "image": "sipecam/audio-dgpi-kale-tensorflow-yuntu-dask-cert:0.6.1_dev"}},
          "inputs": [{"name": "CUMULO", "type": "Integer"}, {"name": "PAGESIZE", "type":
          "Integer"}, {"name": "SAMPLERATE", "type": "Float"}], "name": "Get audio
          df"}', pipelines.kubeflow.org/component_ref: '{}', pipelines.kubeflow.org/arguments.parameters: '{"CUMULO":
          "{{inputs.parameters.CUMULO}}", "PAGESIZE": "{{inputs.parameters.PAGESIZE}}",
          "SAMPLERATE": "{{inputs.parameters.SAMPLERATE}}"}'}
      labels:
        pipelines.kubeflow.org/metadata_written: "true"
        pipelines.kubeflow.org/kfp_sdk_version: 1.8.11
        pipelines.kubeflow.org/pipeline-sdk-type: kfp
        pipelines.kubeflow.org/enable_caching: "true"
    volumes:
    - name: pvolume-ef6fe65091618f865041935b363277953274adf6b420fd4a7b8277d
      persistentVolumeClaim: {claimName: '{{inputs.parameters.vol_shared_volume}}'}
  - name: sound-scape-nod-rec-dep-tons1
    inputs:
      parameters:
      - {name: BLUE_IDX}
      - {name: CUMULO}
      - {name: FREQUENCY_BINS}
      - {name: FREQUENCY_LIMITS_LB}
      - {name: FREQUENCY_LIMITS_UB}
      - {name: GREEN_IDX}
      - {name: HASHER_TIME_MODULE}
      - {name: HASHER_TIME_UNIT}
      - {name: HASH_NAME}
      - {name: MIN_FREQ_SC}
      - {name: PAGESIZE}
      - {name: RED_IDX}
      - {name: RESULTS_DIR}
      - {name: SAMPLERATE}
      - {name: SPECTRUM}
      - {name: THREADS_PER_WORKER}
      - {name: TIME_UNIT}
      - {name: WORK_DIR_PIPELINE}
      - {name: vol_shared_volume}
    dag:
      tasks:
      - name: compute-soundscapes
        template: compute-soundscapes
        dependencies: [create-results-dirstruct, get-audio-df]
        arguments:
          parameters:
          - {name: BLUE_IDX, value: '{{inputs.parameters.BLUE_IDX}}'}
          - {name: CUMULO, value: '{{inputs.parameters.CUMULO}}'}
          - {name: FREQUENCY_BINS, value: '{{inputs.parameters.FREQUENCY_BINS}}'}
          - {name: FREQUENCY_LIMITS_LB, value: '{{inputs.parameters.FREQUENCY_LIMITS_LB}}'}
          - {name: FREQUENCY_LIMITS_UB, value: '{{inputs.parameters.FREQUENCY_LIMITS_UB}}'}
          - {name: GREEN_IDX, value: '{{inputs.parameters.GREEN_IDX}}'}
          - {name: HASHER_TIME_MODULE, value: '{{inputs.parameters.HASHER_TIME_MODULE}}'}
          - {name: HASHER_TIME_UNIT, value: '{{inputs.parameters.HASHER_TIME_UNIT}}'}
          - {name: HASH_NAME, value: '{{inputs.parameters.HASH_NAME}}'}
          - {name: MIN_FREQ_SC, value: '{{inputs.parameters.MIN_FREQ_SC}}'}
          - {name: RED_IDX, value: '{{inputs.parameters.RED_IDX}}'}
          - {name: RESULTS_DIR, value: '{{inputs.parameters.RESULTS_DIR}}'}
          - {name: SPECTRUM, value: '{{inputs.parameters.SPECTRUM}}'}
          - {name: THREADS_PER_WORKER, value: '{{inputs.parameters.THREADS_PER_WORKER}}'}
          - {name: TIME_UNIT, value: '{{inputs.parameters.TIME_UNIT}}'}
          - {name: WORK_DIR_PIPELINE, value: '{{inputs.parameters.WORK_DIR_PIPELINE}}'}
          - {name: vol_shared_volume, value: '{{inputs.parameters.vol_shared_volume}}'}
      - name: create-results-dirstruct
        template: create-results-dirstruct
        dependencies: [get-audio-df]
        arguments:
          parameters:
          - {name: CUMULO, value: '{{inputs.parameters.CUMULO}}'}
          - {name: RESULTS_DIR, value: '{{inputs.parameters.RESULTS_DIR}}'}
          - {name: vol_shared_volume, value: '{{inputs.parameters.vol_shared_volume}}'}
      - name: get-audio-df
        template: get-audio-df
        arguments:
          parameters:
          - {name: CUMULO, value: '{{inputs.parameters.CUMULO}}'}
          - {name: PAGESIZE, value: '{{inputs.parameters.PAGESIZE}}'}
          - {name: SAMPLERATE, value: '{{inputs.parameters.SAMPLERATE}}'}
          - {name: vol_shared_volume, value: '{{inputs.parameters.vol_shared_volume}}'}
  arguments:
    parameters:
    - {name: BLUE_IDX, value: CORE}
    - {name: CUMULO, value: '92'}
    - {name: FREQUENCY_BINS, value: '96'}
    - {name: FREQUENCY_LIMITS_LB, value: '0'}
    - {name: FREQUENCY_LIMITS_UB, value: '24000'}
    - {name: GREEN_IDX, value: INFORMATION}
    - {name: HASHER_TIME_MODULE, value: '48'}
    - {name: HASHER_TIME_UNIT, value: '1800'}
    - {name: HASH_NAME, value: crono_hash_30m}
    - {name: MIN_FREQ_SC, value: '10000'}
    - {name: PAGESIZE, value: '1000'}
    - {name: RED_IDX, value: EXAG}
    - {name: RESULTS_DIR, value: /shared_volume/audio/soundscapes}
    - {name: SAMPLERATE, value: '48000.0'}
    - {name: SPECTRUM, value: Audible}
    - {name: THREADS_PER_WORKER, value: '2'}
    - {name: TIME_UNIT, value: '30'}
    - {name: WORK_DIR_PIPELINE, value: .}
    - {name: vol_shared_volume, value: hostpath-pvc}
  serviceAccountName: pipeline-runner
